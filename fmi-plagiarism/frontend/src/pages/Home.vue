<template>
  <q-page>
   <div class="text-left" style="margin: 20px">
     Софийски университет “Св. Климент <br>
     Охридски” <br>
     Факултет по математика и информатика <br>
     Курсов проект по “Системи <br>
     основани на знания” <br>
     зимен семестър 2021/2022 <br>
     Тема - Plagiarism system <br>
     Изработили: Веселин Славов Тодоров <br>
     71923, Кенан Кемал Юсеин 71947, <br>
     Лъчезар Атанасов Пещерлиев 71930 <br>
     Специалност: Информационни системи <br>
     Курс: 3 <br>
     Гр. София <br>
     Декември 2021 <br>
   </div>
   <div class="text-left" style="margin: 20px">
     Съдържание: <br>
     1. Задание – кратко описание на решаваната <br>
     задача <br>
     2. Описание на използвания/предложения <br>
     алгоритъм за решаване на задачата <br>
     3. Описание на данните – описание на структурата <br>
     и произхода на използваните данни <br>
     4. Описание на особеностите на <br>
     създадения/използвания програмен код <br>
     5. Примерни резултати от работата на създаденото <br>
     приложение <br>
     6. Оценка на ефективността на реализацията. <br>
   </div>
    <div class="text-left" style="margin: 20px">
      1. Задание – кратко описание на
      решаваната задача <br>
      Поради онлайн обучението, много изпити и контролни се
      правят на компютър, което води до лесно преписване. По
      тази причина идеята на нашия проект е система за
      плагиатство (“plagiarism checker”). При нея можем да
      добавим множество файлове, като се сравнява
      съдържанието на файловете и намира процентът на
      съвпадение в текста, като използва алгоритъма на
      Левенщайн и някои оптимизации свързани с по-точните
      резултати, които той дава. Системата е имплементирана
      под формата на Уеб приложение, в която могат свободно
      да се зареждат файловете, и да изведе в кои файлове,
      какъв е процента на плагиатство спрямо тяхното
      съдържание.
    </div>
    <div class="text-left" style="margin: 20px">
      2. Описание на използвания
      алгоритъм за решаване на задачата <br>
      Основния алгоритъм, който е използван е алгоритъма на
      Левенщайн, който открива броя промени(като замяна на
      символ с друг символ, размяна на позициите на два
      символа, изтриване на символ) на даден низ са нужни, за
      да го превърнем в друг низ (нарича се още Левенщайново
      разстояние). За да бъде, обаче алгоритъма оптимален
      трябва да премахнем всички препинателни знаци, които
      биха били отчетени като плагиатство. Също така, тъй като
      стандартно има разлика като малки и главни букви, трябва
      да игнорираме разликата между малки и главни букви.
      Алгоритмите, които ще приложим върху двата низа преди
      да използваме алгоритъма на Левенщайн са алгоритъм за
      премахване на препинателни знаци, и превръщане на
      главните букви в малки. След това на преработените
      низове прилагаме алгоритъм който премахва много често
      срещани думи като ‘be’, ‘when’, ‘was’ и др.
      Псевдокод за алгоритъма за изчистване на препинателни
      знаци и игнорирането на малки и главни букви: <br>
      tokenize(string text): <br>
      listOfWords = text.split(“(\s+)|([.,!?:;'\"\'-])”); <br>
      for(word : listOfWords) <br>
      { <br>
      if(word.isEmpty()) <br>
      { <br>
      listOfWords.remove(word); <br>
      continue; <br>
      } <br>
      word = word.toLowerCase(); <br>
      } <br>
      return listOfWords; <br>
      Псевдокод за алгоритъма за изчистване на често <br>
      срещаните думи: <br>
      commonWords е листът с често срещани думи <br>
      stem(list string listOfWords): <br>
      for(word : listOfWords) <br>
      { <br>
      if(commonWords.contains(word)) <br>
      { <br>
      listOfWords.remove(word); <br>
      continue; <br>
      } <br>
      } <br>
      return listOfWords.joining(‘ ’); <br>
      Алгоритъма на Левенщайн приема 2та низа и извършва
      следните стъпки:<br>
      1. Ако единия от двата низа е празен, то броя промени
      ще бъде дължината на втория низ, например ако
      имаме низовете “hello” и “” броя промени ще е 5.<br>
      2. Ако двата низа не са празни, то изчисленото
      разстоянието на всяка стъпка ще се държи в матрица
      n x m, където n e дължината на първия низ + 1, а m е
      дължината на втория низ + 1. Запълваме първия ред и
      първата колона на матрицата с последователни числа
      като започваме от 0.<br>
      3. За останалите клетки в матрицата (с координати i и j)
      ще попълним 0, ако символа на позиция i - 1 в първия
      низ и символа на позиция j - 1 във втория низ, в
      противен случай ще попълним 1<br>
      4. За всяка клетка освен от ред и колона 1 разстоянието
      може да бъде изчислено използвайки следния код
      Псевдокод: <br>
      levenstein(fst, snd)<br>
      {<br>
      if(fst == “” or snd == “”) { <br>
      return max(fst.size, snd.size); <br>
      } <br>
      for(int i : fst.size) <br>
      { <br>
      for(int j: snd.size) <br>
      { <br>
      int cost = (fst[i] == snd[j]) ? 0 : 1; <br>
      distance[i][j] = min( <br>
      min(distance[i-1][j] + 1, distance[i][j-1]+1), <br>
      distance[i-1][j-1] + cost <br>
      }} <br>
      return distance[fst.size-1][snd.size-1]; <br>
      } <br>
      След като се намерим колко стъпки са нужни, за промяна
      на низа, процента плагиатство се изчислява като 1 - броя
      стъпки / дължината на по дългия низ.
    </div>
    <div class="text-left" style="margin: 20px">
      3. Описание на данните – описание
      на структурата и произхода на
      използваните данни <br>
      Входните данни са 2 низа, а изходния резултат е цяло
      число от 0 до 100, като информацията идва от
      файлове (използва се разширение .txt, но лесно и
      бързо могат да бъдат добавени и други формати на
      файлове). В приложението има бутон за добавяне на
      файловете, като в база от данни се записва
      съдържанието на файловете и от там се извличат за
      прилагане на алгоритъма. Крайния резултат излиза в
      приложението. Списъка с често срещани думи е взет
      от следния адрес: The 100 most common words in
      English – Espresso English.
    </div>
    <div class="text-left" style="margin: 20px">
      4. Описание на особеностите на
      създадения програмен код <br>
      Проектът представлява УЕБ приложение изработено чрез следните технологии:
      Backend - Oracle Database + Liquibase, Kotlin with Spring boot + JOOQ
      REST api - spring rest
      Frontend - Vue.js, Quasar, Vite, Axious, TS<br>
      Кодът за алгоритъма е написан на езика Java, и са
      използвани част от удобствата на езика. Като за начало
      при 2та мутиращи низовете алгоритъма, се използват
      stream, поради удобството от декларативния подход който
      предлагатmap и filter функциите, които притежава.<br>
      Също
      така както се вижда в приложената снимка се използват и
      предоставения от езика метод за минаване от главна в
      малка буква toLower. За да бъдат удобни за използване
      първия алгоритъм връща списъка от думи в двата низа,
      които да могат лесно сравнявани със списъка с често
      срещани думи и да бъдат лесно премахнати, когато това се
      налага. В крайна сметка обаче резултата от двата метода е
      символен низ
    </div>
   <div class="text-left" style="margin: 20px">
     5. Примерни резултати от работата
     на създаденото приложение <br>
     В програмния код има създадени тестове за приложения
     алгоритъм: <br>
     Тест 1:<br>
     “He went to the kitchen”<br>
     “He went to the kitchen”<br>
     => 100% - двата низа са равни тоест има пълно
     плагиатство<br>
     Тест 2:<br>
     “He went to the kitchen”<br>
     "The man was in the kitchen last night"<br>
     => 48% - тук повторение има само на думата kitchen, тъй
     като думите to, the, in и was се премахват като често
     срещани думи. Тоест низовете които се сравняват са “He
     went kitchen”, “Man kitchen last night”.<br>
     Тест 3:<br>
     “hello”<br>
     “”<br>
     => 0% няма плагиатство защото единия низ е празен.<br>
     Тест 4:<br>
     “to kitchen”<br>
     “kitchen”<br>
     =>70% плагиатство, думата to се премахва, но празното
     място остава, което означава че трябва да се премахне за
     да има еднаквост на низовете.
   </div>
    <div class="text-left" style="margin: 20px">
      6. Оценка на ефективността на
      реализацията. <br>
      Алгоритъма на левенщайн използва два вложени цикъла
      съответно с n и m на брой итерации (дължините на двата
      низа), което дава сложност по време O(n*m) (или O(nm)).
      Освен това помощните алгоритми изискват обхождания на
      2та масива следователно двата алгоритъма имат сложност
      O(n + m), тоест общата оценка на алгоритъма по време е
      O(nm + 2(n+m)), което може да се сведе до O(nm).
      Сложността на алгоритъма по памет отново е O(nm), тъй
      като имаме матрица с n реда и m колони.
      Забележка: Подобрение към алгоритъма би било начин
      по който да се хваща не само пряко плагиатство, а и
      промяна на словоред, когато смисъла при размяна на думи
      не би променило смисъла на изречението. Също така
      алгоритъма използва изключително доста памет и при
      дълги низове би бил доста неефективен, което може да се
      оптимизира чрез промяна на матрицата в друга структура
      от данни като списък от списъци които да държат
      минималния брой стъпки във всеки момент.
    </div>
  </q-page>
</template>

<script lang="ts" setup>
</script>

<style scoped>

</style>